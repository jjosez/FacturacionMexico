{"version":3,"file":"core.js","names":["config: EtaConfig","compileBody","buffer: Array<AstObject>","leftTrim: string | false","rightTrim: string | false","escMap: { [key: string]: string }","defaultConfig: EtaConfig","buffer: Array<AstObject>","trimLeftOfNextStr: string | false","m: RegExpExecArray | null","closeTag: RegExpExecArray | null","currentObj: AstObject | false","templateFn: TemplateFunction","cache: Record<string, T>","Eta","EtaCore"],"sources":["../src/err.ts","../src/compile.ts","../src/compile-string.ts","../src/utils.ts","../src/config.ts","../src/parse.ts","../src/render.ts","../src/storage.ts","../src/internal.ts","../src/core.ts"],"sourcesContent":["export class EtaError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"Eta Error\";\n  }\n}\n\nexport class EtaParseError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaParser Error\";\n  }\n}\n\nexport class EtaRuntimeError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaRuntime Error\";\n  }\n}\n\nexport class EtaFileResolutionError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaFileResolution Error\";\n  }\n}\n\nexport class EtaNameResolutionError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaNameResolution Error\";\n  }\n}\n\n/**\n * Throws an EtaError with a nicely formatted error and message showing where in the template the error occurred.\n */\n\nexport function ParseErr(message: string, str: string, indx: number): never {\n  const whitespace = str.slice(0, indx).split(/\\n/);\n\n  const lineNo = whitespace.length;\n  const colNo = whitespace[lineNo - 1].length + 1;\n  message +=\n    \" at line \" +\n    lineNo +\n    \" col \" +\n    colNo +\n    \":\\n\\n\" +\n    \"  \" +\n    str.split(/\\n/)[lineNo - 1] +\n    \"\\n\" +\n    \"  \" +\n    Array(colNo).join(\" \") +\n    \"^\";\n  throw new EtaParseError(message);\n}\n\nexport function RuntimeErr(\n  originalError: Error,\n  str: string,\n  lineNo: number,\n  path: string,\n): never {\n  // code gratefully taken from https://github.com/mde/ejs and adapted\n\n  const lines = str.split(\"\\n\");\n  const start = Math.max(lineNo - 3, 0);\n  const end = Math.min(lines.length, lineNo + 3);\n  const filename = path;\n  // Error context\n  const context = lines\n    .slice(start, end)\n    .map((line, i) => {\n      const curr = i + start + 1;\n      return (curr === lineNo ? \" >> \" : \"    \") + curr + \"| \" + line;\n    })\n    .join(\"\\n\");\n\n  const header = filename\n    ? filename + \":\" + lineNo + \"\\n\"\n    : \"line \" + lineNo + \"\\n\";\n\n  const err = new EtaRuntimeError(\n    header + context + \"\\n\\n\" + originalError.message,\n  );\n\n  err.name = originalError.name; // the original name (e.g. ReferenceError) may be useful\n  err.cause = originalError;\n\n  throw err;\n}\n","import type { EtaConfig, Options } from \"./config.ts\";\nimport { EtaParseError } from \"./err.ts\";\nimport type { Eta } from \"./internal.ts\";\n\nexport type TemplateFunction = (\n  this: Eta,\n  data?: object,\n  options?: Partial<Options>,\n) => string;\n/* END TYPES */\n\n/* istanbul ignore next */\nconst AsyncFunction = (async () => {}).constructor;\n\n/**\n * Takes a template string and returns a template function that can be called with (data, config)\n *\n * @param str - The template string\n * @param config - A custom configuration object (optional)\n */\n\nexport function compile(\n  this: Eta,\n  str: string,\n  options?: Partial<Options>,\n): TemplateFunction {\n  const config: EtaConfig = this.config;\n\n  /* ASYNC HANDLING */\n  // code gratefully taken from https://github.com/mde/ejs and adapted\n  const ctor = options?.async\n    ? (AsyncFunction as FunctionConstructor)\n    : Function;\n  /* END ASYNC HANDLING */\n\n  try {\n    return new ctor(\n      config.varName,\n      \"options\",\n      this.compileToString.call(this, str, options),\n    ) as TemplateFunction; // eslint-disable-line no-new-func\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw new EtaParseError(\n        \"Bad template syntax\\n\\n\" +\n          e.message +\n          \"\\n\" +\n          Array(e.message.length + 1).join(\"=\") +\n          \"\\n\" +\n          this.compileToString.call(this, str, options) +\n          \"\\n\", // This will put an extra newline before the callstack for extra readability\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n","import type { Options } from \"./config.ts\";\nimport type { Eta } from \"./internal.ts\";\nimport type { AstObject } from \"./parse.ts\";\n\n/**\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\n */\n\nexport function compileToString(\n  this: Eta,\n  str: string,\n  options?: Partial<Options>,\n): string {\n  const config = this.config;\n  const isAsync = options?.async;\n\n  const compileBody = this.compileBody;\n\n  const buffer: Array<AstObject> = this.parse.call(this, str);\n\n  // note: when the include function passes through options, the only parameter that matters is the filepath parameter\n  let res = `${config.functionHeader}\nlet include = (__eta_t, __eta_d) => this.render(__eta_t, {...${config.varName}, ...(__eta_d ?? {})}, options);\nlet includeAsync = (__eta_t, __eta_d) => this.renderAsync(__eta_t, {...${config.varName}, ...(__eta_d ?? {})}, options);\n\nlet __eta = {res: \"\", e: this.config.escapeFunction, f: this.config.filterFunction${\n    config.debug\n      ? ', line: 1, templateStr: \"' +\n        str.replace(/\\\\|\"/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\") +\n        '\"'\n      : \"\"\n  }};\n\nfunction layout(path, data) {\n  __eta.layout = path;\n  __eta.layoutData = data;\n}${config.debug ? \"try {\" : \"\"}${\n    config.useWith ? \"with(\" + config.varName + \"||{}){\" : \"\"\n  }\n\nfunction ${config.outputFunctionName}(s){__eta.res+=s;}\n\n${compileBody.call(this, buffer)}\nif (__eta.layout) {\n  __eta.res = ${\n    isAsync ? \"await includeAsync\" : \"include\"\n  } (__eta.layout, {...${\n    config.varName\n  }, body: __eta.res, ...__eta.layoutData});\n}\n${config.useWith ? \"}\" : \"\"}${\n  config.debug\n    ? \"} catch (e) { this.RuntimeErr(e, __eta.templateStr, __eta.line, options.filepath) }\"\n    : \"\"\n}\nreturn __eta.res;\n`;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processFnString) {\n        res = plugin.processFnString(res, config);\n      }\n    }\n  }\n\n  return res;\n}\n\n/**\n * Loops through the AST generated by `parse` and transform each item into JS calls\n *\n * **Example**\n *\n * ```js\n * let templateAST = ['Hi ', { val: 'it.name', t: 'i' }]\n * compileBody.call(Eta, templateAST)\n * // => \"__eta.res+='Hi '\\n__eta.res+=__eta.e(it.name)\\n\"\n * ```\n */\n\nexport function compileBody(this: Eta, buff: Array<AstObject>): string {\n  const config = this.config;\n\n  let i = 0;\n  const buffLength = buff.length;\n  let returnStr = \"\";\n\n  for (i; i < buffLength; i++) {\n    const currentBlock = buff[i];\n    if (typeof currentBlock === \"string\") {\n      const str = currentBlock;\n\n      // we know string exists\n      returnStr += \"__eta.res+='\" + str + \"'\\n\";\n    } else {\n      const type = currentBlock.t; // \"r\", \"e\", or \"i\"\n      let content = currentBlock.val || \"\";\n\n      if (config.debug) returnStr += \"__eta.line=\" + currentBlock.lineNo + \"\\n\";\n\n      if (type === \"r\") {\n        // raw\n\n        if (config.autoFilter) {\n          content = \"__eta.f(\" + content + \")\";\n        }\n\n        returnStr += \"__eta.res+=\" + content + \"\\n\";\n      } else if (type === \"i\") {\n        // interpolate\n\n        if (config.autoFilter) {\n          content = \"__eta.f(\" + content + \")\";\n        }\n\n        if (config.autoEscape) {\n          content = \"__eta.e(\" + content + \")\";\n        }\n\n        returnStr += \"__eta.res+=\" + content + \"\\n\";\n      } else if (type === \"e\") {\n        // execute\n        returnStr += content + \"\\n\";\n      }\n    }\n  }\n\n  return returnStr;\n}\n","import type { EtaConfig } from \"./config.ts\";\n\n/**\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\n */\n\nexport function trimWS(\n  str: string,\n  config: EtaConfig,\n  wsLeft: string | false,\n  wsRight?: string | false,\n): string {\n  let leftTrim: string | false;\n  let rightTrim: string | false;\n\n  if (Array.isArray(config.autoTrim)) {\n    // Slightly confusing,\n    // but _}} will trim the left side of the following string\n    leftTrim = config.autoTrim[1];\n    rightTrim = config.autoTrim[0];\n  } else {\n    leftTrim = rightTrim = config.autoTrim;\n  }\n\n  if (wsLeft || wsLeft === false) {\n    leftTrim = wsLeft;\n  }\n\n  if (wsRight || wsRight === false) {\n    rightTrim = wsRight;\n  }\n\n  if (!rightTrim && !leftTrim) {\n    return str;\n  }\n\n  if (leftTrim === \"slurp\" && rightTrim === \"slurp\") {\n    return str.trim();\n  }\n\n  if (leftTrim === \"_\" || leftTrim === \"slurp\") {\n    // full slurp\n    str = str.trimStart();\n  } else if (leftTrim === \"-\" || leftTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/^(?:\\r\\n|\\n|\\r)/, \"\");\n  }\n\n  if (rightTrim === \"_\" || rightTrim === \"slurp\") {\n    // full slurp\n    str = str.trimEnd();\n  } else if (rightTrim === \"-\" || rightTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/(?:\\r\\n|\\n|\\r)$/, \"\");\n  }\n\n  return str;\n}\n\n/**\n * A map of special HTML characters to their XML-escaped equivalents\n */\n\nconst escMap: { [key: string]: string } = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nfunction replaceChar(s: string): string {\n  return escMap[s];\n}\n\n/**\n * XML-escapes an input value after converting it to a string\n *\n * @param str - Input value (usually a string)\n * @returns XML-escaped string\n */\n\nexport function XMLEscape(str: unknown): string {\n  // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\n  const newStr = String(str);\n  if (/[&<>\"']/.test(newStr)) {\n    return newStr.replace(/[&<>\"']/g, replaceChar);\n  } else {\n    return newStr;\n  }\n}\n","import type { AstObject } from \"./parse.ts\";\nimport { XMLEscape } from \"./utils.ts\";\n\ntype trimConfig = \"nl\" | \"slurp\" | false;\n\nexport interface Options {\n  /** Compile to async function */\n  async?: boolean;\n\n  /** Absolute path to template file */\n  filepath?: string;\n}\n\nexport interface EtaConfig {\n  /** Whether or not to automatically XML-escape interpolations. Default true */\n  autoEscape: boolean;\n\n  /** Apply a filter function defined on the class to every interpolation or raw interpolation */\n  autoFilter: boolean;\n\n  /** Configure automatic whitespace trimming. Default `[false, 'nl']` */\n  autoTrim: trimConfig | [trimConfig, trimConfig];\n\n  /** Whether or not to cache templates if `name` or `filename` is passed */\n  cache: boolean;\n\n  /** Holds cache of resolved filepaths. Set to `false` to disable. */\n  cacheFilepaths: boolean;\n\n  /** Whether to pretty-format error messages (introduces runtime penalties) */\n  debug: boolean;\n\n  /** Function to XML-sanitize interpolations */\n  escapeFunction: (str: unknown) => string;\n\n  /** Function applied to all interpolations when autoFilter is true */\n  filterFunction: (val: unknown) => string;\n\n  /** Name of the function that can be used in template code to output text to the result (like EJS's `outputFunctionName`). */\n  outputFunctionName: string;\n\n  /** Raw JS code inserted in the template function. Useful for declaring global variables for user templates */\n  functionHeader: string;\n\n  /** Parsing options */\n  parse: {\n    /** Which prefix to use for evaluation. Default `\"\"`, does not support `\"-\"` or `\"_\"` */\n    exec: string;\n\n    /** Which prefix to use for interpolation. Default `\"=\"`, does not support `\"-\"` or `\"_\"` */\n    interpolate: string;\n\n    /** Which prefix to use for raw interpolation. Default `\"~\"`, does not support `\"-\"` or `\"_\"` */\n    raw: string;\n  };\n\n  /** Array of plugins */\n  plugins: Array<{\n    processFnString?: (fnString: string, env?: EtaConfig) => string;\n    processAST?: (ast: AstObject[], env?: EtaConfig) => AstObject[];\n    processTemplate?: (fnString: string, env?: EtaConfig) => string;\n  }>;\n\n  /** Remove empty lines and whitespace between lines */\n  rmWhitespace: boolean;\n\n  /** Delimiters: by default `['<%', '%>']` */\n  tags: [string, string];\n\n  /** Make data available on the global object instead of varName */\n  useWith: boolean;\n\n  /** Name of the data object. Default `it` */\n  varName: string;\n\n  /** Directory that contains templates */\n  views?: string;\n\n  /** Control template file extension defaults. Default `.eta` */\n  defaultExtension?: string;\n}\n\n/* END TYPES */\n\n/** Eta's base (global) configuration */\nconst defaultConfig: EtaConfig = {\n  autoEscape: true,\n  autoFilter: false,\n  autoTrim: [false, \"nl\"],\n  cache: false,\n  cacheFilepaths: true,\n  debug: false,\n  escapeFunction: XMLEscape,\n  // default filter function (not used unless enables) just stringifies the input\n  filterFunction: (val) => String(val),\n  outputFunctionName: \"output\",\n  functionHeader: \"\",\n  parse: {\n    exec: \"\",\n    interpolate: \"=\",\n    raw: \"~\",\n  },\n  plugins: [],\n  rmWhitespace: false,\n  tags: [\"<%\", \"%>\"],\n  useWith: false,\n  varName: \"it\",\n  defaultExtension: \".eta\",\n};\n\nexport { defaultConfig };\n","import { ParseErr } from \"./err.ts\";\nimport type { Eta } from \"./internal.ts\";\nimport { trimWS } from \"./utils.ts\";\n\nexport type TagType = \"r\" | \"e\" | \"i\" | \"\";\n\nexport interface TemplateObject {\n  t: TagType;\n  val: string;\n  lineNo?: number;\n}\n\nexport type AstObject = string | TemplateObject;\n\n/* END TYPES */\n\nconst templateLitReg =\n  /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g;\n\nconst singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g;\n\nconst doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g;\n\n/** Escape special regular expression characters inside a string */\n\nfunction escapeRegExp(string: string) {\n  // From MDN\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\nfunction getLineNo(str: string, index: number) {\n  return str.slice(0, index).split(\"\\n\").length;\n}\n\nexport function parse(this: Eta, str: string): Array<AstObject> {\n  const config = this.config;\n\n  let buffer: Array<AstObject> = [];\n  let trimLeftOfNextStr: string | false = false;\n  let lastIndex = 0;\n  const parseOptions = config.parse;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processTemplate) {\n        str = plugin.processTemplate(str, config);\n      }\n    }\n  }\n\n  /* Adding for EJS compatibility */\n  if (config.rmWhitespace) {\n    // Code taken directly from EJS\n    // Have to use two separate replaces here as `^` and `$` operators don't\n    // work well with `\\r` and empty lines don't work well with the `m` flag.\n    // Essentially, this replaces the whitespace at the beginning and end of\n    // each line and removes multiple newlines.\n    str = str.replace(/[\\r\\n]+/g, \"\\n\").replace(/^\\s+|\\s+$/gm, \"\");\n  }\n  /* End rmWhitespace option */\n\n  templateLitReg.lastIndex = 0;\n  singleQuoteReg.lastIndex = 0;\n  doubleQuoteReg.lastIndex = 0;\n\n  function pushString(strng: string, shouldTrimRightOfString?: string | false) {\n    if (strng) {\n      // if string is truthy it must be of type 'string'\n\n      strng = trimWS(\n        strng,\n        config,\n        trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\n        shouldTrimRightOfString,\n      );\n\n      if (strng) {\n        // replace \\ with \\\\, ' with \\'\n        // we're going to convert all CRLF to LF so it doesn't take more than one replace\n\n        strng = strng.replace(/\\\\|'/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\");\n\n        buffer.push(strng);\n      }\n    }\n  }\n\n  const prefixes = [\n    parseOptions.exec,\n    parseOptions.interpolate,\n    parseOptions.raw,\n  ].reduce((accumulator, prefix) => {\n    if (accumulator && prefix) {\n      return accumulator + \"|\" + escapeRegExp(prefix);\n    } else if (prefix) {\n      // accumulator is falsy\n      return escapeRegExp(prefix);\n    } else {\n      // prefix and accumulator are both falsy\n      return accumulator;\n    }\n  }, \"\");\n\n  const parseOpenReg = new RegExp(\n    escapeRegExp(config.tags[0]) + \"(-|_)?\\\\s*(\" + prefixes + \")?\\\\s*\",\n    \"g\",\n  );\n\n  const parseCloseReg = new RegExp(\n    \"'|\\\"|`|\\\\/\\\\*|(\\\\s*(-|_)?\" + escapeRegExp(config.tags[1]) + \")\",\n    \"g\",\n  );\n\n  let m: RegExpExecArray | null;\n\n  // biome-ignore lint/suspicious/noAssignInExpressions: this is performant\n  while ((m = parseOpenReg.exec(str))) {\n    const precedingString = str.slice(lastIndex, m.index);\n\n    lastIndex = m[0].length + m.index;\n\n    const wsLeft = m[1];\n    const prefix = m[2] || \"\"; // by default either ~, =, or empty\n\n    pushString(precedingString, wsLeft);\n\n    parseCloseReg.lastIndex = lastIndex;\n    let closeTag: RegExpExecArray | null;\n    let currentObj: AstObject | false = false;\n\n    // biome-ignore lint/suspicious/noAssignInExpressions: this is performant\n    while ((closeTag = parseCloseReg.exec(str))) {\n      if (closeTag[1]) {\n        const content = str.slice(lastIndex, closeTag.index);\n\n        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex;\n\n        trimLeftOfNextStr = closeTag[2];\n\n        const currentType: TagType =\n          prefix === parseOptions.exec\n            ? \"e\"\n            : prefix === parseOptions.raw\n              ? \"r\"\n              : prefix === parseOptions.interpolate\n                ? \"i\"\n                : \"\";\n\n        currentObj = { t: currentType, val: content };\n        break;\n      } else {\n        const char = closeTag[0];\n        if (char === \"/*\") {\n          const commentCloseInd = str.indexOf(\"*/\", parseCloseReg.lastIndex);\n\n          if (commentCloseInd === -1) {\n            ParseErr(\"unclosed comment\", str, closeTag.index);\n          }\n          parseCloseReg.lastIndex = commentCloseInd;\n        } else if (char === \"'\") {\n          singleQuoteReg.lastIndex = closeTag.index;\n\n          const singleQuoteMatch = singleQuoteReg.exec(str);\n          if (singleQuoteMatch) {\n            parseCloseReg.lastIndex = singleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === '\"') {\n          doubleQuoteReg.lastIndex = closeTag.index;\n          const doubleQuoteMatch = doubleQuoteReg.exec(str);\n\n          if (doubleQuoteMatch) {\n            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === \"`\") {\n          templateLitReg.lastIndex = closeTag.index;\n          const templateLitMatch = templateLitReg.exec(str);\n          if (templateLitMatch) {\n            parseCloseReg.lastIndex = templateLitReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        }\n      }\n    }\n    if (currentObj) {\n      if (config.debug) {\n        currentObj.lineNo = getLineNo(str, m.index);\n      }\n      buffer.push(currentObj);\n    } else {\n      ParseErr(\"unclosed tag\", str, m.index);\n    }\n  }\n\n  pushString(str.slice(lastIndex, str.length), false);\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processAST) {\n        buffer = plugin.processAST(buffer, config);\n      }\n    }\n  }\n\n  return buffer;\n}\n","import type { TemplateFunction } from \"./compile.ts\";\n\n/* TYPES */\nimport type { Options } from \"./config.ts\";\nimport { EtaNameResolutionError } from \"./err.ts\";\nimport type { Eta } from \"./internal.ts\";\n\n/* END TYPES */\n\nfunction handleCache(\n  this: Eta,\n  template: string,\n  options: Partial<Options>,\n): TemplateFunction {\n  const templateStore = options?.async\n    ? this.templatesAsync\n    : this.templatesSync;\n\n  if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n    const templatePath = options.filepath as string;\n\n    const cachedTemplate = templateStore.get(templatePath);\n\n    if (this.config.cache && cachedTemplate) {\n      return cachedTemplate;\n    } else {\n      const templateString = this.readFile(templatePath);\n\n      const templateFn = this.compile(templateString, options);\n\n      if (this.config.cache) templateStore.define(templatePath, templateFn);\n\n      return templateFn;\n    }\n  } else {\n    const cachedTemplate = templateStore.get(template);\n\n    if (cachedTemplate) {\n      return cachedTemplate;\n    } else {\n      throw new EtaNameResolutionError(`Failed to get template '${template}'`);\n    }\n  }\n}\n\nexport function render<T extends object>(\n  this: Eta,\n  template: string | TemplateFunction, // template name or template function\n  data: T,\n  meta?: { filepath: string },\n): string {\n  let templateFn: TemplateFunction;\n  const options = { ...meta, async: false };\n\n  if (typeof template === \"string\") {\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n      options.filepath = this.resolvePath(template, options);\n    }\n\n    templateFn = handleCache.call(this, template, options);\n  } else {\n    templateFn = template;\n  }\n\n  const res = templateFn.call(this, data, options);\n\n  return res;\n}\n\nexport function renderAsync<T extends object>(\n  this: Eta,\n  template: string | TemplateFunction, // template name or template function\n  data: T,\n  meta?: { filepath: string },\n): Promise<string> {\n  let templateFn: TemplateFunction;\n  const options = { ...meta, async: true };\n\n  if (typeof template === \"string\") {\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n      options.filepath = this.resolvePath(template, options);\n    }\n\n    templateFn = handleCache.call(this, template, options);\n  } else {\n    templateFn = template;\n  }\n\n  const res = templateFn.call(this, data, options);\n\n  // Return a promise\n  return Promise.resolve(res);\n}\n\nexport function renderString<T extends object>(\n  this: Eta,\n  template: string,\n  data: T,\n): string {\n  const templateFn = this.compile(template, { async: false });\n\n  return render.call(this, templateFn, data);\n}\n\nexport function renderStringAsync<T extends object>(\n  this: Eta,\n  template: string,\n  data: T,\n): Promise<string> {\n  const templateFn = this.compile(template, { async: true });\n\n  return renderAsync.call(this, templateFn, data);\n}\n","/**\n * Handles storage and accessing of values\n *\n * In this case, we use it to store compiled template functions\n * Indexed by their `name` or `filename`\n */\n\nexport class Cacher<T> {\n  constructor(private cache: Record<string, T>) {}\n  define(key: string, val: T): void {\n    this.cache[key] = val;\n  }\n  get(key: string): T {\n    return this.cache[key];\n  }\n  remove(key: string): void {\n    delete this.cache[key];\n  }\n  reset(): void {\n    this.cache = {};\n  }\n  load(cacheObj: Record<string, T>): void {\n    this.cache = { ...this.cache, ...cacheObj };\n  }\n}\n","import type { TemplateFunction } from \"./compile.ts\";\nimport { compile } from \"./compile.ts\";\nimport { compileBody, compileToString } from \"./compile-string.ts\";\nimport type { EtaConfig, Options } from \"./config.ts\";\nimport { defaultConfig } from \"./config.ts\";\nimport { EtaError, RuntimeErr } from \"./err.ts\";\nimport { parse } from \"./parse.ts\";\nimport {\n  render,\n  renderAsync,\n  renderString,\n  renderStringAsync,\n} from \"./render.ts\";\nimport { Cacher } from \"./storage.ts\";\n\nexport class Eta {\n  constructor(customConfig?: Partial<EtaConfig>) {\n    if (customConfig) {\n      this.config = { ...defaultConfig, ...customConfig };\n    } else {\n      this.config = { ...defaultConfig };\n    }\n  }\n\n  config: EtaConfig;\n\n  RuntimeErr = RuntimeErr;\n\n  compile = compile;\n  compileToString = compileToString;\n  compileBody = compileBody;\n  parse = parse;\n  render = render;\n  renderAsync = renderAsync;\n  renderString = renderString;\n  renderStringAsync = renderStringAsync;\n\n  filepathCache: Record<string, string> = {};\n  templatesSync: Cacher<TemplateFunction> = new Cacher<TemplateFunction>({});\n  templatesAsync: Cacher<TemplateFunction> = new Cacher<TemplateFunction>({});\n\n  // resolvePath takes a relative path from the \"views\" directory\n  resolvePath:\n    | null\n    | ((this: Eta, template: string, options?: Partial<Options>) => string) =\n    null;\n  readFile: null | ((this: Eta, path: string) => string) = null;\n\n  // METHODS\n\n  configure(customConfig: Partial<EtaConfig>) {\n    this.config = { ...this.config, ...customConfig };\n  }\n\n  withConfig(customConfig: Partial<EtaConfig>): this & { config: EtaConfig } {\n    return { ...this, config: { ...this.config, ...customConfig } };\n  }\n\n  loadTemplate(\n    name: string,\n    template: string | TemplateFunction, // template string or template function\n    options?: { async: boolean },\n  ): void {\n    if (typeof template === \"string\") {\n      const templates = options?.async\n        ? this.templatesAsync\n        : this.templatesSync;\n\n      templates.define(name, this.compile(template, options));\n    } else {\n      let templates = this.templatesSync;\n\n      if (template.constructor.name === \"AsyncFunction\" || options?.async) {\n        templates = this.templatesAsync;\n      }\n\n      templates.define(name, template);\n    }\n  }\n}\n\n// for instance checking against thrown errors\nexport { EtaError };\n","import { Eta as EtaCore } from \"./internal.ts\";\n\nexport type { TemplateFunction } from \"./compile.ts\";\nexport type { EtaConfig, Options } from \"./config.ts\";\nexport {\n  EtaError,\n  EtaFileResolutionError,\n  EtaNameResolutionError,\n  EtaParseError,\n  EtaRuntimeError,\n} from \"./err.ts\";\n\nexport class Eta extends EtaCore {}\n"],"mappings":"AAAA,IAAa,EAAb,cAA8B,KAAM,CAClC,YAAY,EAAiB,CAC3B,MAAM,EAAQ,CACd,KAAK,KAAO,cAIH,EAAb,cAAmC,CAAS,CAC1C,YAAY,EAAiB,CAC3B,MAAM,EAAQ,CACd,KAAK,KAAO,oBAIH,EAAb,cAAqC,CAAS,CAC5C,YAAY,EAAiB,CAC3B,MAAM,EAAQ,CACd,KAAK,KAAO,qBAIH,EAAb,cAA4C,CAAS,CACnD,YAAY,EAAiB,CAC3B,MAAM,EAAQ,CACd,KAAK,KAAO,4BAIH,EAAb,cAA4C,CAAS,CACnD,YAAY,EAAiB,CAC3B,MAAM,EAAQ,CACd,KAAK,KAAO,4BAQhB,SAAgB,EAAS,EAAiB,EAAa,EAAqB,CAC1E,IAAM,EAAa,EAAI,MAAM,EAAG,EAAK,CAAC,MAAM,KAAK,CAE3C,EAAS,EAAW,OACpB,EAAQ,EAAW,EAAS,GAAG,OAAS,EAa9C,KAZA,IACE,YACA,EACA,QACA,EACA;;IAEA,EAAI,MAAM,KAAK,CAAC,EAAS,GACzB;IAEA,MAAM,EAAM,CAAC,KAAK,IAAI,CACtB,IACI,IAAI,EAAc,EAAQ,CAGlC,SAAgB,EACd,EACA,EACA,EACA,EACO,CAGP,IAAM,EAAQ,EAAI,MAAM;EAAK,CACvB,EAAQ,KAAK,IAAI,EAAS,EAAG,EAAE,CAC/B,EAAM,KAAK,IAAI,EAAM,OAAQ,EAAS,EAAE,CACxC,EAAW,EAEX,EAAU,EACb,MAAM,EAAO,EAAI,CACjB,KAAK,EAAM,IAAM,CAChB,IAAM,EAAO,EAAI,EAAQ,EACzB,OAAQ,IAAS,EAAS,OAAS,QAAU,EAAO,KAAO,GAC3D,CACD,KAAK;EAAK,CAMP,EAAM,IAAI,GAJD,EACX,EAAW,IAAM,EAAS;EAC1B,QAAU,EAAS;GAGZ,EAAU;;EAAS,EAAc,QAC3C,CAKD,KAHA,GAAI,KAAO,EAAc,KACzB,EAAI,MAAQ,EAEN,EC/ER,MAAM,GAAiB,SAAY,IAAI,YASvC,SAAgB,EAEd,EACA,EACkB,CAClB,IAAMA,EAAoB,KAAK,OAIzB,EAAO,GAAS,MACjB,EACD,SAGJ,GAAI,CACF,OAAO,IAAI,EACT,EAAO,QACP,UACA,KAAK,gBAAgB,KAAK,KAAM,EAAK,EAAQ,CAC9C,OACM,EAAG,CAYR,MAXE,aAAa,YACT,IAAI,EACR;;EACE,EAAE,QACF;EACA,MAAM,EAAE,QAAQ,OAAS,EAAE,CAAC,KAAK,IAAI,CACrC;EACA,KAAK,gBAAgB,KAAK,KAAM,EAAK,EAAQ,CAC7C;EACH,CAEK,GC7CZ,SAAgB,EAEd,EACA,EACQ,CACR,IAAM,EAAS,KAAK,OACd,EAAU,GAAS,MAEnBC,EAAc,KAAK,YAEnBC,EAA2B,KAAK,MAAM,KAAK,KAAM,EAAI,CAGvD,EAAM,GAAG,EAAO,eAAe;+DAC0B,EAAO,QAAQ;yEACL,EAAO,QAAQ;;oFAGpF,EAAO,MACH,4BACA,EAAI,QAAQ,QAAS,OAAO,CAAC,QAAQ,cAAe,MAAM,CAC1D,IACA,GACL;;;;;GAKA,EAAO,MAAQ,QAAU,KACxB,EAAO,QAAU,QAAU,EAAO,QAAU,SAAW,GACxD;;WAEQ,EAAO,mBAAmB;;EAEnCD,EAAY,KAAK,KAAM,EAAO,CAAC;;gBAG7B,EAAU,qBAAuB,UAClC,sBACC,EAAO,QACR;;EAED,EAAO,QAAU,IAAM,KACvB,EAAO,MACH,sFACA,GACL;;EAIC,GAAI,EAAO,QACT,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,QAAQ,OAAQ,IAAK,CAC9C,IAAM,EAAS,EAAO,QAAQ,GAC1B,EAAO,kBACT,EAAM,EAAO,gBAAgB,EAAK,EAAO,EAK/C,OAAO,EAeT,SAAgB,EAAuB,EAAgC,CACrE,IAAM,EAAS,KAAK,OAEhB,EAAI,EACF,EAAa,EAAK,OACpB,EAAY,GAEhB,KAAQ,EAAI,EAAY,IAAK,CAC3B,IAAM,EAAe,EAAK,GAC1B,GAAI,OAAO,GAAiB,SAI1B,GAAa,eAHD,EAGwB;MAC/B,CACL,IAAM,EAAO,EAAa,EACtB,EAAU,EAAa,KAAO,GAE9B,EAAO,QAAO,GAAa,cAAgB,EAAa,OAAS;GAEjE,IAAS,KAGP,EAAO,aACT,EAAU,WAAa,EAAU,KAGnC,GAAa,cAAgB,EAAU;GAC9B,IAAS,KAGd,EAAO,aACT,EAAU,WAAa,EAAU,KAG/B,EAAO,aACT,EAAU,WAAa,EAAU,KAGnC,GAAa,cAAgB,EAAU;GAC9B,IAAS,MAElB,GAAa,EAAU;IAK7B,OAAO,EC3HT,SAAgB,EACd,EACA,EACA,EACA,EACQ,CACR,IAAIE,EACAC,EA2CJ,OAzCI,MAAM,QAAQ,EAAO,SAAS,EAGhC,EAAW,EAAO,SAAS,GAC3B,EAAY,EAAO,SAAS,IAE5B,EAAW,EAAY,EAAO,UAG5B,GAAU,IAAW,MACvB,EAAW,IAGT,GAAW,IAAY,MACzB,EAAY,GAGV,CAAC,GAAa,CAAC,EACV,EAGL,IAAa,SAAW,IAAc,QACjC,EAAI,MAAM,EAGf,IAAa,KAAO,IAAa,QAEnC,EAAM,EAAI,WAAW,EACZ,IAAa,KAAO,IAAa,QAE1C,EAAM,EAAI,QAAQ,kBAAmB,GAAG,EAGtC,IAAc,KAAO,IAAc,QAErC,EAAM,EAAI,SAAS,EACV,IAAc,KAAO,IAAc,QAE5C,EAAM,EAAI,QAAQ,kBAAmB,GAAG,EAGnC,GAOT,MAAMC,EAAoC,CACxC,IAAK,QACL,IAAK,OACL,IAAK,OACL,IAAK,SACL,IAAK,QACN,CAED,SAAS,EAAY,EAAmB,CACtC,OAAO,EAAO,GAUhB,SAAgB,EAAU,EAAsB,CAE9C,IAAM,EAAS,OAAO,EAAI,CAIxB,MAHE,UAAU,KAAK,EAAO,CACjB,EAAO,QAAQ,WAAY,EAAY,CAEvC,ECHX,MAAMC,EAA2B,CAC/B,WAAY,GACZ,WAAY,GACZ,SAAU,CAAC,GAAO,KAAK,CACvB,MAAO,GACP,eAAgB,GAChB,MAAO,GACP,eAAgB,EAEhB,eAAiB,GAAQ,OAAO,EAAI,CACpC,mBAAoB,SACpB,eAAgB,GAChB,MAAO,CACL,KAAM,GACN,YAAa,IACb,IAAK,IACN,CACD,QAAS,EAAE,CACX,aAAc,GACd,KAAM,CAAC,KAAM,KAAK,CAClB,QAAS,GACT,QAAS,KACT,iBAAkB,OACnB,CC5FK,EACJ,qEAEI,EAAiB,oCAEjB,EAAiB,oCAIvB,SAAS,EAAa,EAAgB,CAEpC,OAAO,EAAO,QAAQ,wBAAyB,OAAO,CAGxD,SAAS,EAAU,EAAa,EAAe,CAC7C,OAAO,EAAI,MAAM,EAAG,EAAM,CAAC,MAAM;EAAK,CAAC,OAGzC,SAAgB,EAAiB,EAA+B,CAC9D,IAAM,EAAS,KAAK,OAEhBC,EAA2B,EAAE,CAC7BC,EAAoC,GACpC,EAAY,EACV,EAAe,EAAO,MAE5B,GAAI,EAAO,QACT,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,QAAQ,OAAQ,IAAK,CAC9C,IAAM,EAAS,EAAO,QAAQ,GAC1B,EAAO,kBACT,EAAM,EAAO,gBAAgB,EAAK,EAAO,EAM3C,EAAO,eAMT,EAAM,EAAI,QAAQ,WAAY;EAAK,CAAC,QAAQ,cAAe,GAAG,EAIhE,EAAe,UAAY,EAC3B,EAAe,UAAY,EAC3B,EAAe,UAAY,EAE3B,SAAS,EAAW,EAAe,EAA0C,CACvE,IAGF,EAAQ,EACN,EACA,EACA,EACA,EACD,CAEG,IAIF,EAAQ,EAAM,QAAQ,QAAS,OAAO,CAAC,QAAQ,cAAe,MAAM,CAEpE,EAAO,KAAK,EAAM,GAKxB,IAAM,EAAW,CACf,EAAa,KACb,EAAa,YACb,EAAa,IACd,CAAC,QAAQ,EAAa,IACjB,GAAe,EACV,EAAc,IAAM,EAAa,EAAO,CACtC,EAEF,EAAa,EAAO,CAGpB,EAER,GAAG,CAEA,EAAmB,OACvB,EAAa,EAAO,KAAK,GAAG,CAAG,cAAgB,EAAW,SAC1D,IACD,CAEK,EAAoB,OACxB,4BAA8B,EAAa,EAAO,KAAK,GAAG,CAAG,IAC7D,IACD,CAEGC,EAGJ,KAAQ,EAAI,EAAa,KAAK,EAAI,EAAG,CACnC,IAAM,EAAkB,EAAI,MAAM,EAAW,EAAE,MAAM,CAErD,EAAY,EAAE,GAAG,OAAS,EAAE,MAE5B,IAAM,EAAS,EAAE,GACX,EAAS,EAAE,IAAM,GAEvB,EAAW,EAAiB,EAAO,CAEnC,EAAc,UAAY,EAC1B,IAAIC,EACAC,EAAgC,GAGpC,KAAQ,EAAW,EAAc,KAAK,EAAI,EACxC,GAAI,EAAS,GAAI,CACf,IAAM,EAAU,EAAI,MAAM,EAAW,EAAS,MAAM,CAEpD,EAAa,UAAY,EAAY,EAAc,UAEnD,EAAoB,EAAS,GAW7B,EAAa,CAAE,EARb,IAAW,EAAa,KACpB,IACA,IAAW,EAAa,IACtB,IACA,IAAW,EAAa,YACtB,IACA,GAEqB,IAAK,EAAS,CAC7C,UACK,CACL,IAAM,EAAO,EAAS,GACtB,GAAI,IAAS,KAAM,CACjB,IAAM,EAAkB,EAAI,QAAQ,KAAM,EAAc,UAAU,CAE9D,IAAoB,IACtB,EAAS,mBAAoB,EAAK,EAAS,MAAM,CAEnD,EAAc,UAAY,OACjB,IAAS,KAClB,EAAe,UAAY,EAAS,MAEX,EAAe,KAAK,EAAI,CAE/C,EAAc,UAAY,EAAe,UAEzC,EAAS,kBAAmB,EAAK,EAAS,MAAM,EAEzC,IAAS,KAClB,EAAe,UAAY,EAAS,MACX,EAAe,KAAK,EAAI,CAG/C,EAAc,UAAY,EAAe,UAEzC,EAAS,kBAAmB,EAAK,EAAS,MAAM,EAEzC,IAAS,MAClB,EAAe,UAAY,EAAS,MACX,EAAe,KAAK,EAAI,CAE/C,EAAc,UAAY,EAAe,UAEzC,EAAS,kBAAmB,EAAK,EAAS,MAAM,EAKpD,GACE,EAAO,QACT,EAAW,OAAS,EAAU,EAAK,EAAE,MAAM,EAE7C,EAAO,KAAK,EAAW,EAEvB,EAAS,eAAgB,EAAK,EAAE,MAAM,CAM1C,GAFA,EAAW,EAAI,MAAM,EAAW,EAAI,OAAO,CAAE,GAAM,CAE/C,EAAO,QACT,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,QAAQ,OAAQ,IAAK,CAC9C,IAAM,EAAS,EAAO,QAAQ,GAC1B,EAAO,aACT,EAAS,EAAO,WAAW,EAAQ,EAAO,EAKhD,OAAO,ECzMT,SAAS,EAEP,EACA,EACkB,CAClB,IAAM,EAAgB,GAAS,MAC3B,KAAK,eACL,KAAK,cAET,GAAI,KAAK,aAAe,KAAK,UAAY,CAAC,EAAS,WAAW,IAAI,CAAE,CAClE,IAAM,EAAe,EAAQ,SAEvB,EAAiB,EAAc,IAAI,EAAa,CAEtD,GAAI,KAAK,OAAO,OAAS,EACvB,OAAO,EACF,CACL,IAAM,EAAiB,KAAK,SAAS,EAAa,CAE5C,EAAa,KAAK,QAAQ,EAAgB,EAAQ,CAIxD,OAFI,KAAK,OAAO,OAAO,EAAc,OAAO,EAAc,EAAW,CAE9D,OAEJ,CACL,IAAM,EAAiB,EAAc,IAAI,EAAS,CAElD,GAAI,EACF,OAAO,EAEP,MAAM,IAAI,EAAuB,2BAA2B,EAAS,GAAG,EAK9E,SAAgB,EAEd,EACA,EACA,EACQ,CACR,IAAIC,EACE,EAAU,CAAE,GAAG,EAAM,MAAO,GAAO,CAczC,OAZI,OAAO,GAAa,UAClB,KAAK,aAAe,KAAK,UAAY,CAAC,EAAS,WAAW,IAAI,GAChE,EAAQ,SAAW,KAAK,YAAY,EAAU,EAAQ,EAGxD,EAAa,EAAY,KAAK,KAAM,EAAU,EAAQ,EAEtD,EAAa,EAGH,EAAW,KAAK,KAAM,EAAM,EAAQ,CAKlD,SAAgB,EAEd,EACA,EACA,EACiB,CACjB,IAAIA,EACE,EAAU,CAAE,GAAG,EAAM,MAAO,GAAM,CAEpC,OAAO,GAAa,UAClB,KAAK,aAAe,KAAK,UAAY,CAAC,EAAS,WAAW,IAAI,GAChE,EAAQ,SAAW,KAAK,YAAY,EAAU,EAAQ,EAGxD,EAAa,EAAY,KAAK,KAAM,EAAU,EAAQ,EAEtD,EAAa,EAGf,IAAM,EAAM,EAAW,KAAK,KAAM,EAAM,EAAQ,CAGhD,OAAO,QAAQ,QAAQ,EAAI,CAG7B,SAAgB,EAEd,EACA,EACQ,CACR,IAAM,EAAa,KAAK,QAAQ,EAAU,CAAE,MAAO,GAAO,CAAC,CAE3D,OAAO,EAAO,KAAK,KAAM,EAAY,EAAK,CAG5C,SAAgB,EAEd,EACA,EACiB,CACjB,IAAM,EAAa,KAAK,QAAQ,EAAU,CAAE,MAAO,GAAM,CAAC,CAE1D,OAAO,EAAY,KAAK,KAAM,EAAY,EAAK,CCxGjD,IAAa,EAAb,KAAuB,CACrB,YAAY,EAAkC,CAA1B,KAAA,MAAA,EACpB,OAAO,EAAa,EAAc,CAChC,KAAK,MAAM,GAAO,EAEpB,IAAI,EAAgB,CAClB,OAAO,KAAK,MAAM,GAEpB,OAAO,EAAmB,CACxB,OAAO,KAAK,MAAM,GAEpB,OAAc,CACZ,KAAK,MAAQ,EAAE,CAEjB,KAAK,EAAmC,CACtC,KAAK,MAAQ,CAAE,GAAG,KAAK,MAAO,GAAG,EAAU,GCPlCE,EAAb,KAAiB,CACf,YAAY,EAAmC,CACzC,EACF,KAAK,OAAS,CAAE,GAAG,EAAe,GAAG,EAAc,CAEnD,KAAK,OAAS,CAAE,GAAG,EAAe,CAItC,OAEA,WAAa,EAEb,QAAU,EACV,gBAAkB,EAClB,YAAc,EACd,MAAQ,EACR,OAAS,EACT,YAAc,EACd,aAAe,EACf,kBAAoB,EAEpB,cAAwC,EAAE,CAC1C,cAA0C,IAAI,EAAyB,EAAE,CAAC,CAC1E,eAA2C,IAAI,EAAyB,EAAE,CAAC,CAG3E,YAGE,KACF,SAAyD,KAIzD,UAAU,EAAkC,CAC1C,KAAK,OAAS,CAAE,GAAG,KAAK,OAAQ,GAAG,EAAc,CAGnD,WAAW,EAAgE,CACzE,MAAO,CAAE,GAAG,KAAM,OAAQ,CAAE,GAAG,KAAK,OAAQ,GAAG,EAAc,CAAE,CAGjE,aACE,EACA,EACA,EACM,CACN,GAAI,OAAO,GAAa,UACJ,GAAS,MACvB,KAAK,eACL,KAAK,eAEC,OAAO,EAAM,KAAK,QAAQ,EAAU,EAAQ,CAAC,KAClD,CACL,IAAI,EAAY,KAAK,eAEjB,EAAS,YAAY,OAAS,iBAAmB,GAAS,SAC5D,EAAY,KAAK,gBAGnB,EAAU,OAAO,EAAM,EAAS,IChEzB,EAAb,cAAyBC,CAAQ"}